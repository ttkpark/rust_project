---
title: "Day 5 - 임베디드 메모리 구조 완전 정리: .text, .data, .bss, stack, heap"
date: 2025-04-07
categories: [rust_project]
tags: [Rust, Embedded, STM32, Memory Layout, .text, .bss, rust_project]
description: "STM32에서의 빌드 결과로 나타나는 .text, .data, .bss, stack, heap의 의미와 각 섹션이 메모리에서 어떤 역할을 하는지를 Rust 관점에서 풀어봅니다."
---

오늘은 STM32에서 Rust로 작성한 코드를 처음으로 빌드하고, 다음과 같은 빌드 결과를 확인했다:

```
   text    data     bss     dec     hex filename
    800       0       4     804     324 target/thumbv7m-none-eabi/release/stm32f103-blinky
```

이 숫자들을 보고 “아 이게 용량이구나~” 하고 넘길 수도 있지만, 사실 이 구조는 **임베디드 메모리 동작의 본질**을 그대로 보여준다.  
오늘은 이 `text`, `data`, `bss`, `stack`, `heap`이 정확히 어떤 의미이고, 어디에 저장되는지를 정리해보았다.

---

## 1. `.text`: 프로그램 코드 (FLASH)

- **설명**: 우리가 작성한 Rust 코드(컴파일된 어셈블리)가 저장되는 공간
- **위치**: FLASH 메모리 (비휘발성)
- **특징**:
  - 실행 가능한 코드
  - read-only
  - 크기가 클수록 펌웨어가 커진다는 뜻

### 예시

```
text: 800 (bytes)
```

약 2KB의 Flash 공간을 코드가 차지했다는 의미. `.text`가 커진다는 건 곧 펌웨어가 커진다는 뜻!

---

## 2. `.data`: 초기화된 전역 변수 (RAM)

- **설명**: 초기값이 있는 전역 변수 저장 공간
- **위치**: RAM (초기값은 FLASH에서 복사됨)
- **특징**:
  - 전원 ON 시 FLASH에서 복사됨
  - 읽기/쓰기 모두 가능

### 예시

```
data: 0 (bytes)
```

아직 초기값을 갖는 전역 변수를 선언하지 않았기 때문에, `data` 섹션은 0.

---

## 3. `.bss`: 초기값이 없는 전역 변수 (RAM)

- **설명**: 초기화되지 않은 전역 변수 저장소 (기본적으로 0으로 클리어됨)
- **위치**: RAM
- **특징**:
  - 부팅 시 0으로 초기화
  - `.data`보다 가볍고 빠름

### 예시

```
bss: 4 (bytes)
```

아주 작은 전역 변수 (예: `static mut COUNT: u32 = 0;`) 같은 게 들어갔을 가능성.

---

## 4. `stack`: 지역 변수, 함수 호출 스택 (RAM)

- **설명**: 함수 호출 시 지역 변수 저장, 리턴 주소 저장 등
- **위치**: RAM (보통 RAM의 상위 주소부터 아래로 성장)
- **특징**:
  - LIFO 구조
  - 너무 깊은 재귀나 큰 배열로 overflow 가능

💡 대부분의 문제는 “stack overflow”로 발생!  
RTFM, RTIC 프레임워크에서는 stack size를 명시적으로 설정할 수 있음.

---

## 5. `heap`: 동적 메모리 할당 공간 (RAM)

- **설명**: Box, Vec, String 등 동적 할당 시 사용
- **위치**: RAM (stack과 반대 방향으로 성장)
- **특징**:
  - 기본 `no_std` 환경에서는 사용 불가
  - 보통 사용하지 않음

> Rust의 임베디드 세계에서는 heap 없이 작동하는 구조가 기본이다.

---

## 6. 전체 메모리 구조 다이어그램

```
+------------------------+ ← RAM END (상위주소)
|        Stack           |
|         ↓              |
|------------------------|
|        Heap            |
|         ↑              |
|------------------------|
| .bss  (0 init global)  |
| .data (init global)    |
|------------------------|
|        .text           | ← FLASH 영역
+------------------------+ ← 주소 0x0800_0000 (STM32 기준)
```

---

## 7. `dec`와 `hex`는 총 용량

```
dec: 804   → 전체 프로그램 크기 (bytes)
hex: 324   → 16진수로 표현한 크기
```

이 값은 `.text + .data + .bss` 의 합계이며, 실제 펌웨어의 무게를 알려준다.

---

## 8. 어떻게 확인할 수 있나?

Rust에서는 다음 명령어로 확인 가능:

```bash
arm-none-eabi-size target/thumbv7m-none-eabi/release/프로젝트명
```

또는 `.elf` 파일을 분석하는 도구도 있다:

```bash
arm-none-eabi-objdump -h target/.../*.elf
```

---

## 🔁 정리

| 섹션 | 저장 위치 | 역할 | 특징 |
|------|------------|------|------|
| `.text` | FLASH | 실행 코드 | 읽기 전용 |
| `.data` | RAM | 초기화된 전역 변수 | 부팅 시 FLASH → RAM 복사 |
| `.bss` | RAM | 초기화 안된 전역 변수 | 부팅 시 0으로 초기화 |
| `stack` | RAM | 함수 지역 변수, 호출 스택 | 자동 성장, overflow 주의 |
| `heap` | RAM | 동적 할당용 | 기본 `no_std`에서는 사용 안 함 |

---

## 느낀 점

임베디드 시스템은 몇 킬로바이트의 차이로 전체 구조가 바뀐다.  
Rust는 그런 시스템에서도 메모리 사용을 정적이고 예측 가능하게 만들어준다.  
오늘 배운 구조는 앞으로의 모든 실습과 프로젝트에서 "기준점"이 될 것이다.