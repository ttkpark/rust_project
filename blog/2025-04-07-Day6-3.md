---
title: "Day 6 - Serial split과 _rx의 의미: 자원을 안전하게 나누는 Rust 방식"
date: 2025-04-07
categories: [rust_project]
tags: [Rust, Embedded, STM32, UART, Ownership, rust_project]
description: "Serial 통신 설정 후 `.split()`을 통해 송수신 객체로 나누는 이유와 `_rx`처럼 변수명을 명시적으로 무시하는 Rust 스타일에 대해 설명합니다."
---

오늘 UART 통신을 구성하면서 `Serial::new()` 로 만든 시리얼 객체를 `.split()`으로 나눠서 `tx`만 사용하는 구조를 구현했다.  
여기서 흥미로운 포인트는 두 가지였다:

1. 왜 굳이 `.split()`을 해야 할까?
2. 그리고 `let (_, _rx)` 가 아닌 `let (mut tx, _rx)`처럼 언더바(`_`)로 시작하는 변수 이름은 어떤 의미를 가질까?

---

## 1. Serial 객체는 하나지만, 내부는 두 개의 자원

`Serial::new(...)` 으로 만든 객체는 `Serial<USART1, (TxPin, RxPin)>` 타입이다.  
이는 **송신(Tx)과 수신(Rx)** 이 결합된 상태이며, 이 자체는 하나의 소유권 구조로 되어 있다.

하지만 우리는 보통:

- **송신만 사용**하거나
- **수신만 인터럽트에 등록**하거나
- **둘을 개별적으로 다루고 싶을** 수 있다.

이때 필요한 것이 `.split()`이다.

---

## 2. `.split()`의 동작 원리

```rust
let (mut tx, _rx) = serial.split();
```

이 코드는 내부적으로 `serial` 객체를 **두 개의 별도 구조체로 분리**합니다:

- `tx: Tx<USART1>`: 송신기 → `writeln!()` 등으로 출력 가능
- `rx: Rx<USART1>`: 수신기 → 보통 인터럽트에서 읽기 용도로 사용

> 💡 `.split()`은 Rust의 소유권 모델을 준수하면서, 내부 자원을 독립적으로 다룰 수 있도록 해줍니다.

---

## 3. 왜 `_rx`처럼 변수명에 `_`를 붙일까?

Rust는 매우 엄격한 언어입니다. **선언해놓고 쓰지 않는 변수는 경고 또는 오류를 발생시킵니다.**

```rust
let (tx, rx) = serial.split(); // ❌ rx를 안 쓰면 컴파일러가 경고
```

이걸 방지하기 위해 두 가지 방법이 있습니다:

- 아예 변수명을 `_`로 선언 → `let (tx, _) = ...`
- 또는 `_rx`처럼 **이름은 있으나 쓰지 않음**을 명시

```rust
let (mut tx, _rx) = serial.split(); // ✅ 의도를 명확히 함
```

### 언제 `_rx`를 쓰는가?

- 나중에 쓸 수도 있다는 의도를 포함
- 문서화와 가독성을 높이기 위해 `_` 단독보다 좋음
- 디버깅 시에도 "이게 Rx였구나"라는 힌트를 줌

---

## 4. split 패턴이 주는 장점

Rust의 소유권 시스템 덕분에, `tx`와 `rx`는 각각 **별개의 가변 자원**이 됩니다.  
이는 다음과 같은 패턴에서 유리합니다:

### ✉️ `tx`만 사용하는 경우

```rust
writeln!(tx, "log message").unwrap();
```

### 📥 `rx`를 인터럽트에 등록하는 경우

```rust
#[interrupt]
fn USART1() {
    // rx.read() 사용
}
```

이처럼 필요에 따라 자원을 쪼갤 수 있는 방식은 **멀티태스킹, 인터럽트 대응, 전역 자원 처리** 등 다양한 구조에서 필수적입니다.

---

## 5. split이 없었다면?

만약 `.split()` 없이 `serial` 객체 자체만 가지고 있었다면:

- `tx`를 사용할 때마다 전체 `serial`의 소유권을 넘겨야 함
- 인터럽트 핸들러와 메인 루프가 동시에 접근할 수 없음
- 불필요한 소유권 이동과 borrow checker 충돌이 발생함

즉, `.split()`은 **직렬 통신 자원을 실제 사용 방식에 맞게 논리적으로 분해**하는 수단입니다.

---

## 🔁 정리

- `.split()`은 `Serial` 객체를 `tx`와 `rx`로 나누어, 각각 독립적으로 다룰 수 있게 한다.
- `tx`: 송신기, `writeln!()` 사용 가능 / `rx`: 수신기, `read()` 혹은 인터럽트용
- `_rx`는 해당 자원을 사용하지 않을 것이란 의도를 컴파일러에 명시
- 이 구조는 소유권, 멀티태스킹, 인터럽트 핸들링에 모두 유리하다
- 앞으로 UART뿐 아니라 SPI, I2C 같은 구조에서도 `.split()` 패턴은 매우 자주 등장할 예정

오늘의 깨달음은 이거다:  
**"자원을 쪼개는 것은 단지 편리함이 아니라, 안전함을 위한 구조다."**