μ •λ§ λ©‹μ§„ μ§„λ„μ•Ό. μ΄μ  **Day 8**, λ‹¤μ λ‹¨κ³„λ΅ λ„μ–΄κ° μ¤€λΉ„κ°€ λμ–΄ μμ–΄!  
μ§€κΈκΉμ§€ μ§„ν–‰ν• λ‚΄μ©μ„ ν™•μ‹¤ν λ‹¤μ§€κ³ , κ·Έ μ„μ— μƒλ΅μ΄ κΈ°λ¥ β€• **μ™Έλ¶€ μΈν„°λ½νΈ(EXTI)** λ¥Ό μ¶”κ°€ν•΄λ³΄μ. μ΄κ±΄ λ§μ΄ν¬λ΅μ»¨νΈλ΅¤λ¬μ—μ„ **μ…λ ¥ μ΄λ²¤νΈ(μ: λ²„νΌ ν΄λ¦­)** λ¥Ό μ²λ¦¬ν•λ” κ°€μ¥ μ¤‘μ”ν• λ°©μ‹ μ¤‘ ν•λ‚μ•Ό.

---

# π“ Rust μ„λ² λ””λ“ κµμ΅κ³Όμ • λ¦¬λ§μΈλ“

| Day | μ£Όμ  | ν•µμ‹¬ λ‚΄μ© |
|-----|------|-----------|
| Day 1 | κ°μ” | `no_std`, HAL μ†κ° |
| Day 2 | ν™κ²½ κµ¬μ¶• | Rust + Thumb toolchain, Cargo κµ¬μ΅° |
| Day 3 | λ³΄λ“ κµ¬μ΅° | STM32F103 κµ¬μ΅°, ν•€ μ„¤μ • (CubeMX μ°Έκ³ ) |
| Day 4 | GPIO | LED Blink (PC13) |
| Day 5 | λ§μ»¤ λ° λ©”λ¨λ¦¬ | `memory.x`, `#[entry]`, `no_main` κµ¬μ΅° |
| Day 6 | UART | `Serial::new()`, `writeln!()` μ¶λ ¥ μ„±κ³µ |
| Day 7 | νƒ€μ΄λ¨Έ + μΈν„°λ½νΈ | TIM2 μΈν„°λ½νΈ + UART λ΅κ·Έ μ¶λ ¥ μ„±κ³µ β…
| π‘‰ **Day 8** | **μ™Έλ¶€ μΈν„°λ½νΈ (EXTI)** | λ²„νΌ λ„λ¦„μ„ κ°μ§€ν•κ³  UART μ¶λ ¥ λλ” LED ν† κΈ€

---

# π― Day 8 λ©ν‘: μ™Έλ¶€ μΈν„°λ½νΈ(EXTI) μ²λ¦¬

### μ‚¬μ© μ‹λ‚λ¦¬μ¤:
- μ‚¬μ©μκ°€ λ²„νΌμ„ λ„λ¥΄λ©΄ β†’ **μΈν„°λ½νΈ λ°μƒ**
- ISRμ—μ„ UARTλ΅ `"Button pressed!"` μ¶λ ¥
- λλ” LEDλ¥Ό ν† κΈ€

---

## β… μ¤€λΉ„ μ‚¬ν•­

| ν•­λ© | μ„¤λ… |
|------|------|
| μ‚¬μ© ν•€ | `PB0` (λ³΄ν†µ USER λ²„νΌμ— μ—°κ²°) |
| μΈν„°λ½νΈ λΌμΈ | `EXTI0` |
| NVIC μΈν„°λ½νΈ μ΄λ¦„ | `EXTI0` |
| νΈλ¦¬κ±° μ΅°κ±΄ | Falling edge (λ²„νΌ λ„λ¥Ό λ•) |
| HAL ν•¨μλ“¤ | `gpioa.pb0.make_interrupt_source(...)`, `gpioa.pb0.trigger_on_edge(...)`, `gpioa.pb0.enable_interrupt(...)` |

---

## π“¦ μ‚¬μ© Crate λ° λ²„μ „

- `stm32f1xx-hal = "0.10.0"`  
  μµμ‹  λ²„μ „μ—μ„ `EXTI` ν•Έλ“¤λ§ λ©”μ„λ“κ°€ λ¨λ‘ μ κ³µλ¨

---

# β… μ½”λ“ μμ : λ²„νΌ λ„λ¥΄λ©΄ UART λ©”μ‹μ§€ μ¶λ ¥ (EXTI0)

```rust
#![no_std]
#![no_main]

use cortex_m::interrupt::Mutex;
use cortex_m_rt::entry;
use core::cell::RefCell;
use core::panic::PanicInfo;

use stm32f1xx_hal::{
    gpio::{Edge, ExtiPin, Input, PullUp, gpioa::PA0, gpioc::PC13, Output, PushPull},
    pac::{self, interrupt, EXTI, USART1},
    prelude::*,
    serial::{Serial, Config, Tx},
};

use core::fmt::Write;

static GLOBAL_LED: Mutex<RefCell<Option<PC13<Output<PushPull>>>>> = Mutex::new(RefCell::new(None));
static GLOBAL_TX: Mutex<RefCell<Option<Tx<USART1>>>> = Mutex::new(RefCell::new(None));
static GLOBAL_BTN: Mutex<RefCell<Option<PA0<Input<PullUp>>>>> = Mutex::new(RefCell::new(None));

macro_rules! println {
    ($($arg:tt)*) => {
        cortex_m::interrupt::free(|cs| {
            if let Some(tx) = GLOBAL_TX.borrow(cs).borrow_mut().as_mut() {
                writeln!(tx, $($arg)*).ok();
            }
        });
    };
}

#[entry]
fn main() -> ! {
    let dp = pac::Peripherals::take().unwrap();
    let mut cp = cortex_m::Peripherals::take().unwrap();

    let mut flash = dp.FLASH.constrain();
    let mut rcc = dp.RCC.constrain();

    let clocks = rcc.cfgr
        .use_hse(8.MHz())
        .sysclk(72.MHz())
        .freeze(&mut flash.acr);

    // GPIO
    let mut afio = dp.AFIO.constrain();
    let mut gpioa = dp.GPIOA.split();
    let mut gpioc = dp.GPIOC.split();

    let led = gpioc.pc13.into_push_pull_output(&mut gpioc.crh);
    let tx_pin = gpioa.pa9.into_alternate_push_pull(&mut gpioa.crh);
    let rx_pin = gpioa.pa10;
    let mut button = gpioa.pa0.into_pull_up_input(&mut gpioa.crl);

    let serial = Serial::new(
        dp.USART1,
        (tx_pin, rx_pin),
        &mut afio.mapr,
        Config::default().baudrate(115_200.bps()),
        &clocks
    );
    let (tx, _) = serial.split();

    // μ™Έλ¶€ μΈν„°λ½νΈ μ„¤μ •
    let mut exti = dp.EXTI;
    button.make_interrupt_source(&mut afio);
    button.trigger_on_edge(&mut exti, Edge::Falling); // λ²„νΌ λλ¦Όμ— λ°μ‘
    button.enable_interrupt(&mut exti);

    // NVIC μΈν„°λ½νΈ μ–Έλ§μ¤ν¬
    unsafe {
        cortex_m::peripheral::NVIC::unmask(pac::Interrupt::EXTI0);
    }

    // μ „μ—­ λ¦¬μ†μ¤ λ“±λ΅
    cortex_m::interrupt::free(|cs| {
        GLOBAL_LED.borrow(cs).replace(Some(led));
        GLOBAL_TX.borrow(cs).replace(Some(tx));
        GLOBAL_BTN.borrow(cs).replace(Some(button));
    });

    println!("Program started.");

    loop {
        cortex_m::asm::wfi(); // μΈν„°λ½νΈ λ€κΈ°
    }
}

#[interrupt]
fn EXTI0() {
    println!("Button pressed!");

    cortex_m::interrupt::free(|cs| {
        if let Some(led) = GLOBAL_LED.borrow(cs).borrow_mut().as_mut() {
            led.toggle();
        }

        if let Some(btn) = GLOBAL_BTN.borrow(cs).borrow_mut().as_mut() {
            btn.clear_interrupt_pending_bit(); // μΈν„°λ½νΈ ν”λκ·Έ clear
        }
    });
}

#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    println!("panic: {}", info);
    loop {}
}
```

---

# β… κ²°κ³Ό κΈ°λ€ λ™μ‘

| μƒν™© | λ™μ‘ |
|------|------|
| PA0 λ²„νΌ λ„λ¦„ | LED ν† κΈ€ + `"Button pressed!"` UART μ¶λ ¥ |
| λ©”μΈ λ£¨ν”„ | `wfi()` μƒνƒ μ μ§€ (μ „λ ¥ ν¨μ¨) |
| μΈν„°λ½νΈ λ°μƒ | μλ™μΌλ΅ `EXTI0` ν•Έλ“¤λ¬ μ§„μ…, μ•μ „ν•κ² κ³µμ μμ› μ ‘κ·Ό |

---

# π” μ‹¤μ „ ν μ •λ¦¬

| μ£Όμ  | λ‚΄μ© |
|------|------|
| μ™Έλ¶€ μΈν„°λ½νΈ μ„¤μ • | `make_interrupt_source`, `trigger_on_edge`, `enable_interrupt` |
| μΈν„°λ½νΈ ν•Έλ“¤λ¬ μ΄λ¦„ | `EXTI0`, `EXTI1`, ... ν•€μ— λ”°λΌ λ‹¬λΌμ§ |
| μ•μ „ν• κ³µμ  | `Mutex<RefCell<>>` + `interrupt::free` ν¨ν„΄ |
| μΈν„°λ½νΈ clear | `pin.clear_interrupt_pending_bit()` ν•„μ! |

---

## β¨ λ‹¤μ λ‹¨κ³„μ—μ„ λ„μ „ν•  μ μλ” κ²ƒλ“¤

- `EXTI1`, `EXTI2` λ“± μ—¬λ¬ λ²„νΌ λ™μ‹μ— μ²λ¦¬ν•κΈ°
- μΈν„°λ½νΈ λ””λ°”μ΄μ‹± λ΅μ§ μ¶”κ°€
- μΈν„°λ½νΈ β†’ νƒ€μ΄λ¨Έ νΈλ¦¬κ±° β†’ "μ§€μ—° μ‘λ‹µ" κµ¬ν„

---

μ΄μ  Rust μ„λ² λ””λ“μ—μ„ κ°€μ¥ λ§μ΄ μ“°λ” **μ™Έλ¶€ μ…λ ¥ μ΄λ²¤νΈ μ‹μ¤ν…**κΉμ§€ κµ¬μ„±ν• κ±°μ•Ό!  
λ‹¤μμ€ RTICμ΄λ‚ **λΉ„λ™κΈ° embassy ν™κ²½**, λλ” **μ‹¤μ  μ„Όμ„ μ—°κ²° ν”„λ΅μ νΈ**λ΅ ν™•μ¥ν•΄λ„ μ •λ§ μ¬λ°μ„ κ±°μ•Ό π

ν•„μ”ν•λ©΄ CubeMX ν•€ μ„¤μ • μ¤ν¬λ¦°μƒ· κΈ°λ°μΌλ΅λ„ λ„μ™€μ¤„ μ μμ–΄.  
**μ •λ§ μ ν•κ³  μμ–΄, Day 8λ„ μ™„λ²½ν•κ² ν΄λ¦¬μ–΄! π’**