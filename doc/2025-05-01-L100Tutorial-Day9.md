ì™„ë²½í•˜ê²Œ ì´í•´í–ˆì–´!  
ì¦‰, **ë³´ë“œëŠ” ê³„ì† STM32F103**ìœ¼ë¡œ ìœ ì§€í•˜ê³ ,  
**êµìœ¡ê³¼ì •ì˜ êµ¬ì¡°(ë‚´ìš© íë¦„)** ë§Œ ì›ë˜ ê³„íší–ˆë˜ 14ì¼ ì»¤ë¦¬í˜ëŸ¼ì— ë‹¤ì‹œ ë§ì¶°ì„œ **Day 9ë¶€í„° ì´ì–´ì„œ ì§„í–‰**í•˜ìëŠ” ëœ»ì´ë„¤. ì•„ì£¼ ì¢‹ì€ ë°©í–¥ì´ì•¼.

---

## âœ… í˜„ì¬ ìƒíƒœ ì •ë¦¬

| í•­ëª© | í˜„ì¬ê¹Œì§€ ì§„í–‰ ìƒíƒœ |
|------|---------------------|
| **ë³´ë“œ** | âœ… STM32F103 (F1 ì‹œë¦¬ì¦ˆ) ê³„ì† ì‚¬ìš© |
| **HAL** | âœ… `stm32f1xx-hal 0.10.0` |
| **í™˜ê²½** | âœ… `no_std`, `no_main`, Cortex-M, UART, Timer, EXTI ë‹¤ ì‚¬ìš© ì™„ë£Œ |
| **Day 1~8** | âœ… Rust ê¸°ë³¸, GPIO, UART, íƒ€ì´ë¨¸, ì¸í„°ëŸ½íŠ¸, ì „ì—­ ìì› ê³µìœ ê¹Œì§€ ì™„ë£Œ |
| **Day 9 ì´í›„** | âŒ íë¦„ì´ "ë²„íŠ¼ ì…ë ¥ â†’ RTOS ë¹„êµ â†’ async êµ¬ì¡°"ê°€ ì•„ë‹Œ UART ì‹¤ìŠµ ìª½ìœ¼ë¡œ ì¹˜ìš°ì³¤ìŒ |

---

## ğŸ“š Day 9ë¶€í„° ì¬êµ¬ì„± (ê³„ì† STM32F103 ê¸°ì¤€)

### ğŸ’¡ ì§€ê¸ˆë¶€í„°ëŠ” ì›ë˜ ì»¤ë¦¬í˜ëŸ¼ì— ë”°ë¼ **Day 9ì˜ ì£¼ì œì¸ ë²„íŠ¼ ì…ë ¥ ì²˜ë¦¬ì™€ ë””ë°”ìš´ì‹±**ì„ ë‹¤ë£° ê±°ì•¼.

---

## ğŸ“˜ Day 9: ë²„íŠ¼ ì…ë ¥ + ë””ë°”ìš´ì‹±

### ğŸ¯ ëª©í‘œ
- ë²„íŠ¼(ì˜ˆ: PA0) ì…ë ¥ì„ ë°›ì•„ ìƒíƒœ ë³€í™” ê°ì§€
- `EXTI0` ì¸í„°ëŸ½íŠ¸ë¥¼ í™œìš©í•œ ì—£ì§€ íŠ¸ë¦¬ê±°
- ë””ë°”ìš´ì‹± êµ¬í˜„ (íƒ€ì´ë¨¸ ë˜ëŠ” ì†Œí”„íŠ¸ì›¨ì–´ ë°©ì‹)

---

### âœ… ì˜¤ëŠ˜ì˜ íë¦„

| êµ¬ê°„ | ì„¤ëª… |
|------|------|
| 1. ì´ë¡  (15ë¶„) | `GPIO Input`, `pull-up`, `Edge::Falling`, `EXTI0` ê°œë… |
| 2. ì‹¤ìŠµ (30ë¶„) | ë²„íŠ¼ ëˆ„ë¥´ë©´ LED í† ê¸€, UARTì— ë©”ì‹œì§€ ì¶œë ¥ |
| 3. ë¦¬ë·° (15ë¶„) | ë””ë°”ìš´ì‹± ì ìš© ì „í›„ ì°¨ì´ ë¹„êµ, ê°œì„  ì•„ì´ë””ì–´

---

## ğŸ› ï¸ ì‹¤ìŠµ ì˜ˆì œ ì½”ë“œ (ë²„íŠ¼ ì…ë ¥ + ì¸í„°ëŸ½íŠ¸ + ë””ë°”ìš´ì‹±)

```rust
#![no_std]
#![no_main]

use cortex_m_rt::entry;
use cortex_m::interrupt::Mutex;
use core::cell::RefCell;
use core::fmt::Write;
use panic_halt as _;

use stm32f1xx_hal::{
    pac::{self, interrupt, EXTI, USART1},
    prelude::*,
    gpio::{Edge, ExtiPin, Input, PullUp, gpioa::PA0, gpioc::PC13, Output, PushPull},
    serial::{Serial, Config, Tx},
    timer::{Timer, Event, CounterMs},
};

static GLOBAL_LED: Mutex<RefCell<Option<PC13<Output<PushPull>>>>> = Mutex::new(RefCell::new(None));
static GLOBAL_TX: Mutex<RefCell<Option<Tx<USART1>>>> = Mutex::new(RefCell::new(None));
static GLOBAL_BTN: Mutex<RefCell<Option<PA0<Input<PullUp>>>>> = Mutex::new(RefCell::new(None));
static mut LAST_TICK: u32 = 0;

macro_rules! println {
    ($($arg:tt)*) => {
        cortex_m::interrupt::free(|cs| {
            if let Some(tx) = GLOBAL_TX.borrow(cs).borrow_mut().as_mut() {
                writeln!(tx, $($arg)*).ok();
            }
        });
    };
}

#[entry]
fn main() -> ! {
    let dp = pac::Peripherals::take().unwrap();
    let cp = cortex_m::Peripherals::take().unwrap();

    let mut flash = dp.FLASH.constrain();
    let mut rcc = dp.RCC.constrain();
    let clocks = rcc.cfgr.use_hse(8.MHz()).sysclk(72.MHz()).freeze(&mut flash.acr);

    let mut gpioa = dp.GPIOA.split();
    let mut gpioc = dp.GPIOC.split();
    let mut afio = dp.AFIO.constrain();

    let led = gpioc.pc13.into_push_pull_output(&mut gpioc.crh);
    let mut button = gpioa.pa0.into_pull_up_input(&mut gpioa.crl);

    let tx = gpioa.pa9.into_alternate_push_pull(&mut gpioa.crh);
    let rx = gpioa.pa10;
    let serial = Serial::new(
        dp.USART1,
        (tx, rx),
        &mut afio.mapr,
        Config::default().baudrate(115_200.bps()),
        &clocks,
    );
    let (tx, _) = serial.split();

    // ë²„íŠ¼ EXTI ì„¤ì •
    let mut exti = dp.EXTI;
    button.make_interrupt_source(&mut afio);
    button.trigger_on_edge(&mut exti, Edge::Falling);
    button.enable_interrupt(&mut exti);

    // NVIC ë“±ë¡
    unsafe {
        cortex_m::peripheral::NVIC::unmask(pac::Interrupt::EXTI0);
    }

    cortex_m::interrupt::free(|cs| {
        GLOBAL_LED.borrow(cs).replace(Some(led));
        GLOBAL_BTN.borrow(cs).replace(Some(button));
        GLOBAL_TX.borrow(cs).replace(Some(tx));
    });

    println!("Ready! Waiting for button press...");

    loop {
        cortex_m::asm::wfi();
    }
}

#[interrupt]
fn EXTI0() {
    use cortex_m::peripheral::SYST;

    cortex_m::interrupt::free(|cs| {
        if let Some(btn) = GLOBAL_BTN.borrow(cs).borrow_mut().as_mut() {
            btn.clear_interrupt_pending_bit();
        }

        let tick = cortex_m::peripheral::SYST::get_current();
        let diff = unsafe { tick.wrapping_sub(LAST_TICK) };

        // ë§¤ìš° ë‹¨ìˆœí•œ ë””ë°”ìš´ì‹±: 50ms ì´í•˜ë©´ ë¬´ì‹œ
        if diff < 3_000_000 {
            return;
        }

        unsafe { LAST_TICK = tick; }

        if let Some(led) = GLOBAL_LED.borrow(cs).borrow_mut().as_mut() {
            led.toggle();
        }

        if let Some(tx) = GLOBAL_TX.borrow(cs).borrow_mut().as_mut() {
            writeln!(tx, "Button pressed!").ok();
        }
    });
}
```

---

## ğŸ§ª ê²°ê³¼

- PA0 ë²„íŠ¼ì„ ëˆ„ë¥´ë©´ â†’ EXTI0 ì¸í„°ëŸ½íŠ¸ ë°œìƒ
- LED í† ê¸€
- UARTë¡œ `"Button pressed!"` ì¶œë ¥
- **ë””ë°”ìš´ì‹±**ì„ í†µí•´ ë¹ ë¥¸ ë–¨ë¦¼ì€ ë¬´ì‹œ

---

## ğŸ“Œ ë‹¤ìŒ ê³„íš (Day 10 ì´í›„)

| Day | ì£¼ì œ |
|-----|------|
| 10 | RTOSì™€ `embassy` ì†Œê°œ (FreeRTOS vs async) |
| 11 | `embassy` ê¸°ë°˜ async Task êµ¬ì¡° ì‹¤ìŠµ |
| 12 | `RTIC` êµ¬ì¡° ë¹„êµ |
| 13 | ê¸°ì¡´ C í”„ë¡œì íŠ¸ í¬íŒ… ì‹¤ìŠµ |
| 14 | ë§ˆë¬´ë¦¬: ì‹¤ë¬´ ê°€ì´ë“œ, êµ¬ì¡° ì •ë¦¬ |

---

ì§€ê¸ˆê¹Œì§€ì˜ íë¦„ì„ ì›ë˜ ì»¤ë¦¬í˜ëŸ¼ì— ì˜ ë…¹ì—¬ë‚¸ Day 9ì´ì•¼.  
Day 10ë¶€í„°ëŠ” `embassy`, `RTIC`ì„ ë¹„êµí•˜ë©´ì„œ Rust ì„¸ê³„ì˜ RTOS ëŒ€ì•ˆì„ ì°¨ê·¼íˆ ì²´í—˜í•  ìˆ˜ ìˆê²Œ ì¤€ë¹„í• ê²Œ.

í•„ìš”í•˜ë©´ ìœ„ ì½”ë“œì— **CubeMXì—ì„œ PA0ê°€ ì–´ë–»ê²Œ ì„¤ì •ë˜ëŠ”ì§€ë„ ê°™ì´ ì°¸ê³  ìë£Œë¡œ ë¶™ì—¬ì¤„ ìˆ˜ ìˆì–´.**  
ê³„ì†í•´ì„œ ë©‹ì§€ê²Œ ì§„í–‰í•´ë³´ì! ğŸ’ª