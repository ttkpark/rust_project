Day 10에서는 STM32F1 마이크로컨트롤러를 활용하여 UART 통신을 통해 외부 명령을 수신하고, 이에 따라 LED를 제어하는 프로젝트를 진행하겠습니다. 이를 통해 UART 수신 인터럽트 처리, 전역 자원 관리, 그리고 안전한 동시성 제어에 대한 이해를 심화할 수 있습니다.

---

## 🧭 목표

- UART 수신 인터럽트를 활용하여 외부 명령을 처리합니다.
- 수신된 명령에 따라 LED를 제어합니다.
- 전역 자원(`Tx`, `Rx`, `LED`)을 안전하게 공유하기 위해 `Mutex`와 `RefCell`을 사용합니다.
- 인터럽트 핸들러 내에서 안전하게 자원을 접근하고 처리합니다.

---

## 🛠️ 사전 준비

- **하드웨어**: STM32F103 보드
- **소프트웨어**:
  - Rust toolchain
  - `stm32f1xx-hal` 크레이트
  - `cortex-m`, `cortex-m-rt`
  - `panic-halt` ([[PDF] 수능직방 Listening_3권](https://www.wjcompass.com/userfiles/downloads/%EC%88%98%EC%A7%81Listening_Level_3_%EC%88%98%EC%A7%81%EB%A6%AC%EC%8A%A4%EB%8B%9D_Answer_Key.pdf?utm_source=chatgpt.com))

---

## 📦 의존성 설정

`Cargo.toml` 파일에 다음과 같이 의존성을 추가합니다:


```toml
[dependencies]
cortex-m = "0.7"
cortex-m-rt = "0.7"
panic-halt = "0.2"
stm32f1xx-hal = { version = "0.10.0", features = ["stm32f103", "rt"] }
```


---

## 🧪 코드 구현


```rust
#![no_std]
#![no_main]

use cortex_m::interrupt::Mutex;
use cortex_m_rt::entry;
use core::cell::RefCell;
use core::fmt::Write;
use panic_halt as _;

use stm32f1xx_hal::{
    pac::{self, interrupt, USART1},
    prelude::*,
    serial::{Config, Serial, Tx, Rx},
    gpio::{gpioc::PC13, Output, PushPull},
};

static GLOBAL_TX: Mutex<RefCell<Option<Tx<USART1>>>> = Mutex::new(RefCell::new(None));
static GLOBAL_RX: Mutex<RefCell<Option<Rx<USART1>>>> = Mutex::new(RefCell::new(None));
static GLOBAL_LED: Mutex<RefCell<Option<PC13<Output<PushPull>>>>> = Mutex::new(RefCell::new(None));

#[entry]
fn main() -> ! {
    let dp = pac::Peripherals::take().unwrap();

    let mut flash = dp.FLASH.constrain();
    let mut rcc = dp.RCC.constrain();

    let clocks = rcc.cfgr.use_hse(8.MHz()).sysclk(72.MHz()).pclk1(36.MHz()).freeze(&mut flash.acr);

    let mut afio = dp.AFIO.constrain();
    let mut gpioa = dp.GPIOA.split();
    let mut gpioc = dp.GPIOC.split();

    let tx_pin = gpioa.pa9.into_alternate_push_pull(&mut gpioa.crh);
    let rx_pin = gpioa.pa10;

    let serial = Serial::new(
        dp.USART1,
        (tx_pin, rx_pin),
        &mut afio.mapr,
        Config::default().baudrate(115_200.bps()),
        &clocks,
    );

    let (tx, rx) = serial.split();

    let led = gpioc.pc13.into_push_pull_output(&mut gpioc.crh);

    cortex_m::interrupt::free(|cs| {
        GLOBAL_TX.borrow(cs).replace(Some(tx));
        GLOBAL_RX.borrow(cs).replace(Some(rx));
        GLOBAL_LED.borrow(cs).replace(Some(led));
    });

    // USART1 수신 인터럽트 활성화
    cortex_m::interrupt::free(|cs| {
        if let Some(ref mut rx) = GLOBAL_RX.borrow(cs).borrow_mut().as_mut() {
            rx.listen();
        }
    });

    // 인터럽트 활성화
    unsafe {
        cortex_m::peripheral::NVIC::unmask(pac::Interrupt::USART1);
    }

    loop {
        // 메인 루프에서는 별도의 작업을 수행하지 않습니다.
        // 모든 처리는 인터럽트 핸들러에서 이루어집니다.
    }
}

#[interrupt]
fn USART1() {
    cortex_m::interrupt::free(|cs| {
        let mut rx_ref = GLOBAL_RX.borrow(cs).borrow_mut();
        let mut tx_ref = GLOBAL_TX.borrow(cs).borrow_mut();
        let mut led_ref = GLOBAL_LED.borrow(cs).borrow_mut();

        if let (Some(rx), Some(tx), Some(led)) = (rx_ref.as_mut(), tx_ref.as_mut(), led_ref.as_mut()) {
            if let Ok(received) = rx.read() {
                match received {
                    b'1' => {
                        led.set_low(); // LED ON
                        writeln!(tx, "LED ON").ok();
                    }
                    b'0' => {
                        led.set_high(); // LED OFF
                        writeln!(tx, "LED OFF").ok();
                    }
                    _ => {
                        writeln!(tx, "Unknown command: {}", received as char).ok();
                    }
                }
            }
        }
    });
}
```


---

## 🔍 주요 구현 사항

1. **전역 자원 관리**: `GLOBAL_TX`, `GLOBAL_RX`, `GLOBAL_LED`를 `Mutex<RefCell<Option<...>>>`로 선언하여 인터럽트와 메인 루프 간의 안전한 자원 공유를 구현하였습니다.

2. **UART 수신 인터럽트 설정**: `rx.listen()`을 호출하여 USART1의 수신 인터럽트를 활성화하고, `NVIC::unmask`를 통해 인터럽트를 허용하였습니다.

3. **인터럽트 핸들러 구현**: `USART1` 인터럽트 핸들러에서 수신된 데이터를 읽고, 해당 명령에 따라 LED를 제어하며, 결과를 UART를 통해 전송합니다.

---

## 🧪 테스트 방법

1. 보드에 코드를 업로드합니다.
2. 시리얼 통신 프로그램(예: PuTTY, Tera Term)을 통해 보드와 통신합니다.
3. 시리얼 창에 `1`을 입력하면 LED가 켜지고, `LED ON` 메시지가 출력됩니다.
4. `0`을 입력하면 LED가 꺼지고, `LED OFF` 메시지가 출력됩니다.
5. 다른 문자를 입력하면 `Unknown command` 메시지가 출력됩니다.

---

## 🧠 마무리

이번 실습을 통해 UART 수신 인터럽트를 활용한 외부 명령 처리와 전역 자원의 안전한 공유 방법에 대해 학습하였습니다. 이러한 기법은 임베디드 시스템에서의 효율적인 이벤트 처리와 리소스 관리를 위한 중요한 기반이 됩니다.

다음 단계로는 여러 개의 명령을 처리하거나, 타이머와 결합하여 주기적인 작업을 수행하는 등의 확장을 고려해볼 수 있습니다.

--- 