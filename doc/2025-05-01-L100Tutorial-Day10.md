Day 10μ—μ„λ” STM32F1 λ§μ΄ν¬λ΅μ»¨νΈλ΅¤λ¬λ¥Ό ν™μ©ν•μ—¬ UART ν†µμ‹ μ„ ν†µν•΄ μ™Έλ¶€ λ…λ Ήμ„ μμ‹ ν•κ³ , μ΄μ— λ”°λΌ LEDλ¥Ό μ μ–΄ν•λ” ν”„λ΅μ νΈλ¥Ό μ§„ν–‰ν•κ² μµλ‹λ‹¤. μ΄λ¥Ό ν†µν•΄ UART μμ‹  μΈν„°λ½νΈ μ²λ¦¬, μ „μ—­ μμ› κ΄€λ¦¬, κ·Έλ¦¬κ³  μ•μ „ν• λ™μ‹μ„± μ μ–΄μ— λ€ν• μ΄ν•΄λ¥Ό μ‹¬ν™”ν•  μ μμµλ‹λ‹¤.

---

## π§­ λ©ν‘

- UART μμ‹  μΈν„°λ½νΈλ¥Ό ν™μ©ν•μ—¬ μ™Έλ¶€ λ…λ Ήμ„ μ²λ¦¬ν•©λ‹λ‹¤.
- μμ‹ λ λ…λ Ήμ— λ”°λΌ LEDλ¥Ό μ μ–΄ν•©λ‹λ‹¤.
- μ „μ—­ μμ›(`Tx`, `Rx`, `LED`)μ„ μ•μ „ν•κ² κ³µμ ν•κΈ° μ„ν•΄ `Mutex`μ™€ `RefCell`μ„ μ‚¬μ©ν•©λ‹λ‹¤.
- μΈν„°λ½νΈ ν•Έλ“¤λ¬ λ‚΄μ—μ„ μ•μ „ν•κ² μμ›μ„ μ ‘κ·Όν•κ³  μ²λ¦¬ν•©λ‹λ‹¤.

---

## π› οΈ μ‚¬μ „ μ¤€λΉ„

- **ν•λ“μ›¨μ–΄**: STM32F103 λ³΄λ“
- **μ†ν”„νΈμ›¨μ–΄**:
  - Rust toolchain
  - `stm32f1xx-hal` ν¬λ μ΄νΈ
  - `cortex-m`, `cortex-m-rt`
  - `panic-halt` ([[PDF] μλ¥μ§λ°© Listening_3κ¶](https://www.wjcompass.com/userfiles/downloads/%EC%88%98%EC%A7%81Listening_Level_3_%EC%88%98%EC%A7%81%EB%A6%AC%EC%8A%A4%EB%8B%9D_Answer_Key.pdf?utm_source=chatgpt.com))

---

## π“¦ μμ΅΄μ„± μ„¤μ •

`Cargo.toml` νμΌμ— λ‹¤μκ³Ό κ°™μ΄ μμ΅΄μ„±μ„ μ¶”κ°€ν•©λ‹λ‹¤:


```toml
[dependencies]
cortex-m = "0.7"
cortex-m-rt = "0.7"
panic-halt = "0.2"
stm32f1xx-hal = { version = "0.10.0", features = ["stm32f103", "rt"] }
```


---

## π§ μ½”λ“ κµ¬ν„


```rust
#![no_std]
#![no_main]

use cortex_m::interrupt::Mutex;
use cortex_m_rt::entry;
use core::cell::RefCell;
use core::fmt::Write;
use panic_halt as _;

use stm32f1xx_hal::{
    pac::{self, interrupt, USART1},
    prelude::*,
    serial::{Config, Serial, Tx, Rx},
    gpio::{gpioc::PC13, Output, PushPull},
};

static GLOBAL_TX: Mutex<RefCell<Option<Tx<USART1>>>> = Mutex::new(RefCell::new(None));
static GLOBAL_RX: Mutex<RefCell<Option<Rx<USART1>>>> = Mutex::new(RefCell::new(None));
static GLOBAL_LED: Mutex<RefCell<Option<PC13<Output<PushPull>>>>> = Mutex::new(RefCell::new(None));

#[entry]
fn main() -> ! {
    let dp = pac::Peripherals::take().unwrap();

    let mut flash = dp.FLASH.constrain();
    let mut rcc = dp.RCC.constrain();

    let clocks = rcc.cfgr.use_hse(8.MHz()).sysclk(72.MHz()).pclk1(36.MHz()).freeze(&mut flash.acr);

    let mut afio = dp.AFIO.constrain();
    let mut gpioa = dp.GPIOA.split();
    let mut gpioc = dp.GPIOC.split();

    let tx_pin = gpioa.pa9.into_alternate_push_pull(&mut gpioa.crh);
    let rx_pin = gpioa.pa10;

    let serial = Serial::new(
        dp.USART1,
        (tx_pin, rx_pin),
        &mut afio.mapr,
        Config::default().baudrate(115_200.bps()),
        &clocks,
    );

    let (tx, rx) = serial.split();

    let led = gpioc.pc13.into_push_pull_output(&mut gpioc.crh);

    cortex_m::interrupt::free(|cs| {
        GLOBAL_TX.borrow(cs).replace(Some(tx));
        GLOBAL_RX.borrow(cs).replace(Some(rx));
        GLOBAL_LED.borrow(cs).replace(Some(led));
    });

    // USART1 μμ‹  μΈν„°λ½νΈ ν™μ„±ν™”
    cortex_m::interrupt::free(|cs| {
        if let Some(ref mut rx) = GLOBAL_RX.borrow(cs).borrow_mut().as_mut() {
            rx.listen();
        }
    });

    // μΈν„°λ½νΈ ν™μ„±ν™”
    unsafe {
        cortex_m::peripheral::NVIC::unmask(pac::Interrupt::USART1);
    }

    loop {
        // λ©”μΈ λ£¨ν”„μ—μ„λ” λ³„λ„μ μ‘μ—…μ„ μν–‰ν•μ§€ μ•μµλ‹λ‹¤.
        // λ¨λ“  μ²λ¦¬λ” μΈν„°λ½νΈ ν•Έλ“¤λ¬μ—μ„ μ΄λ£¨μ–΄μ§‘λ‹λ‹¤.
    }
}

#[interrupt]
fn USART1() {
    cortex_m::interrupt::free(|cs| {
        let mut rx_ref = GLOBAL_RX.borrow(cs).borrow_mut();
        let mut tx_ref = GLOBAL_TX.borrow(cs).borrow_mut();
        let mut led_ref = GLOBAL_LED.borrow(cs).borrow_mut();

        if let (Some(rx), Some(tx), Some(led)) = (rx_ref.as_mut(), tx_ref.as_mut(), led_ref.as_mut()) {
            if let Ok(received) = rx.read() {
                match received {
                    b'1' => {
                        led.set_low(); // LED ON
                        writeln!(tx, "LED ON").ok();
                    }
                    b'0' => {
                        led.set_high(); // LED OFF
                        writeln!(tx, "LED OFF").ok();
                    }
                    _ => {
                        writeln!(tx, "Unknown command: {}", received as char).ok();
                    }
                }
            }
        }
    });
}
```


---

## π” μ£Όμ” κµ¬ν„ μ‚¬ν•­

1. **μ „μ—­ μμ› κ΄€λ¦¬**: `GLOBAL_TX`, `GLOBAL_RX`, `GLOBAL_LED`λ¥Ό `Mutex<RefCell<Option<...>>>`λ΅ μ„ μ–Έν•μ—¬ μΈν„°λ½νΈμ™€ λ©”μΈ λ£¨ν”„ κ°„μ μ•μ „ν• μμ› κ³µμ λ¥Ό κµ¬ν„ν•μ€μµλ‹λ‹¤.

2. **UART μμ‹  μΈν„°λ½νΈ μ„¤μ •**: `rx.listen()`μ„ νΈμ¶ν•μ—¬ USART1μ μμ‹  μΈν„°λ½νΈλ¥Ό ν™μ„±ν™”ν•κ³ , `NVIC::unmask`λ¥Ό ν†µν•΄ μΈν„°λ½νΈλ¥Ό ν—μ©ν•μ€μµλ‹λ‹¤.

3. **μΈν„°λ½νΈ ν•Έλ“¤λ¬ κµ¬ν„**: `USART1` μΈν„°λ½νΈ ν•Έλ“¤λ¬μ—μ„ μμ‹ λ λ°μ΄ν„°λ¥Ό μ½κ³ , ν•΄λ‹Ή λ…λ Ήμ— λ”°λΌ LEDλ¥Ό μ μ–΄ν•λ©°, κ²°κ³Όλ¥Ό UARTλ¥Ό ν†µν•΄ μ „μ†΅ν•©λ‹λ‹¤.

---

## π§ ν…μ¤νΈ λ°©λ²•

1. λ³΄λ“μ— μ½”λ“λ¥Ό μ—…λ΅λ“ν•©λ‹λ‹¤.
2. μ‹λ¦¬μ–Ό ν†µμ‹  ν”„λ΅κ·Έλ¨(μ: PuTTY, Tera Term)μ„ ν†µν•΄ λ³΄λ“μ™€ ν†µμ‹ ν•©λ‹λ‹¤.
3. μ‹λ¦¬μ–Ό μ°½μ— `1`μ„ μ…λ ¥ν•λ©΄ LEDκ°€ μΌμ§€κ³ , `LED ON` λ©”μ‹μ§€κ°€ μ¶λ ¥λ©λ‹λ‹¤.
4. `0`μ„ μ…λ ¥ν•λ©΄ LEDκ°€ κΊΌμ§€κ³ , `LED OFF` λ©”μ‹μ§€κ°€ μ¶λ ¥λ©λ‹λ‹¤.
5. λ‹¤λ¥Έ λ¬Έμλ¥Ό μ…λ ¥ν•λ©΄ `Unknown command` λ©”μ‹μ§€κ°€ μ¶λ ¥λ©λ‹λ‹¤.

---

## π§  λ§λ¬΄λ¦¬

μ΄λ² μ‹¤μµμ„ ν†µν•΄ UART μμ‹  μΈν„°λ½νΈλ¥Ό ν™μ©ν• μ™Έλ¶€ λ…λ Ή μ²λ¦¬μ™€ μ „μ—­ μμ›μ μ•μ „ν• κ³µμ  λ°©λ²•μ— λ€ν•΄ ν•™μµν•μ€μµλ‹λ‹¤. μ΄λ¬ν• κΈ°λ²•μ€ μ„λ² λ””λ“ μ‹μ¤ν…μ—μ„μ ν¨μ¨μ μΈ μ΄λ²¤νΈ μ²λ¦¬μ™€ λ¦¬μ†μ¤ κ΄€λ¦¬λ¥Ό μ„ν• μ¤‘μ”ν• κΈ°λ°μ΄ λ©λ‹λ‹¤.

λ‹¤μ λ‹¨κ³„λ΅λ” μ—¬λ¬ κ°μ λ…λ Ήμ„ μ²λ¦¬ν•κ±°λ‚, νƒ€μ΄λ¨Έμ™€ κ²°ν•©ν•μ—¬ μ£ΌκΈ°μ μΈ μ‘μ—…μ„ μν–‰ν•λ” λ“±μ ν™•μ¥μ„ κ³ λ ¤ν•΄λ³Ό μ μμµλ‹λ‹¤.

--- 